#!/bin/bash

# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source "${DIR}/ide_functions"
GREEN='\033[0;32m'
NC='\033[0m'

helpfunc() {
    echo "Usage: $0 [--group GROUP] [--idefile IDEFILE] COMMAND"
    echo "  --help     Help. Display this message and quit."
    echo "  --version  Version. Print version number and quit."
    echo "  --group    Specify GROUP from Idefile"
    echo "  --idefile  Specify IDEFILE, default is: ./Idefile"
    echo "  --dryrun   Do not pull docker image, do not run docker run."
    exit
}

# Echoes the docker run command, all the arguments are verified already.
# $1 is command to be run in docker container
# $2 is the file with environment variables to be mounted into docker container
construct_docker_command() {
  env_file="$1"
  run_interactively="$2"
  run_id="$3"
  # command can be left not specified, so let it be the last argument
  command="$4"
  if [ -z "$env_file" ]; then
    log_error "env_file not specified"
    return 1;
  fi
  if [ -z "$run_id" ]; then
    log_error "run_id not specified"
    return 1;
  fi
  if [ -z "$run_interactively" ]; then
    log_error "run_interactively not specified"
    return 1;
  fi

  # initial part of the docker command
  docker_cmd="docker run --rm -v $IDE_WORK:/ide/work -v $IDE_IDENTITY:/ide/identity:ro"
  docker_cmd+=" --env-file=\"$env_file\""

  if [ -n "$DISPLAY" ]; then
    # DISPLAY is set, enable running in graphical mode
    docker_cmd+=" -v /tmp/.X11-unix:/tmp/.X11-unix"
  fi

  if [ -n "$IDE_DOCKER_OPTIONS" ]; then
      docker_cmd+=" $IDE_DOCKER_OPTIONS"
  fi

  if [[ "$run_interactively" == "true" ]]; then
      docker_cmd+=" -ti"
  fi

  docker_cmd+=" --name ${run_id}"

  if [ -n "$command" ]; then
      # $command set
      docker_cmd+=" $IDE_DOCKER_IMAGE \"$command\""
  else
      # $command not set
      # why? Because, if $command is set, then we want to quote it.
      # And when $command is not set, we don't want quotes.
      docker_cmd+=" $IDE_DOCKER_IMAGE"
  fi

  echo "$docker_cmd"
}

# default values
groupname="default"
idefile="${PWD}/Idefile"
version="0.3.0"
dryrun="false"

while (( $# > 0 ))
do
    opt="$1"
    shift

    case $opt in
    --help)
        helpfunc
        exit 0
        ;;
    --version)
        echo "$0 version $version"
        exit 0
        ;;
    --group)  # Example with an operand
        log_error "groupnames other than default are not supported"
        exit 1;
        # TODO: support groups
        # groupname="$1"
        # shift
        ;;
    --idefile)  # Example with an operand
        idefile="$1"
        shift
        ;;
    --dryrun)
        dryrun="true"
        ;;
    --force_not_interactive)
        force_not_interactive="true"
        ;;
    --*)
        log_error "Invalid option: '$opt'" >&2
        exit 1
        ;;
    -*)
        log_error "Invalid option: '$opt'" >&2
        exit 1
        ;;
    *)
        # we want to assign N elements as 1 element
        # https://github.com/koalaman/shellcheck/wiki/SC2124
        # this would trigger style violation: command="$opt $@"
        command="$opt $*"
        # the rest of arguments is the command
        break;
        ;;
   esac

done

# verify options
if [ -z "$groupname" ]; then
  log_error "groupname not specified"
  exit 1;
fi
if [ -z "$idefile" ]; then
  log_error "idefile not specified"
  exit 1;
fi
if [ ! -f "$idefile" ]; then
  # do not get full path here with:
  # idefile_full_path=$(readlink -f "$idefile")
  # it will be null
  log_error "idefile: $idefile does not exist (relative to ${PWD})"
  exit 1;
fi
log_debug "Starting ide, version: $version"
log_debug "groupname: $groupname"
log_debug "idefile: $idefile"

# verify Idefile
source "$idefile"
if [ -z "$IDE_DOCKER_IMAGE" ]; then
  log_error "IDE_DOCKER_IMAGE not set"
  exit 1;
fi
if [ -z "$IDE_DRIVER" ]; then
  IDE_DRIVER="docker"
  log_debug "IDE_DRIVER not set, setting to: $IDE_DRIVER"
fi
if [ "$IDE_DRIVER" != "docker" ]; then
  log_error "IDE_DRIVER set to $IDE_DRIVER, supported is only: docker"
  exit 1
fi
if [ -z "$IDE_WORK" ]; then
  IDE_WORK=$PWD
  log_debug "IDE_WORK not set, setting to: $IDE_WORK"
fi
if [ ! -d "$IDE_WORK" ]; then
  log_error "IDE_WORK set to $IDE_WORK which does not exist"
  exit 1
fi
if [ -z "$IDE_IDENTITY" ]; then
  IDE_IDENTITY=$HOME
  log_debug "IDE_IDENTITY not set, setting to: $IDE_IDENTITY"
fi
if [ ! -d "$IDE_IDENTITY" ]; then
  log_error "IDE_IDENTITY set to $IDE_IDENTITY which does not exist"
  exit 1
fi
if [ -z "$IDE_VARS_BLACKLIST" ]; then
  IDE_VARS_BLACKLIST="BASH*,HOME,USERNAME,USER,LOGNAME,PATH,TERM,SHELL,MAIL,SUDO_*,WINDOWID,SSH_*,SESSION_*,GEM_HOME,GEM_PATH,GEM_ROOT,HOSTNAME,HOSTTYPE,IFS,PPID,PWD,OLDPWD"
  log_debug "IDE_VARS_BLACKLIST not set, setting to: $IDE_VARS_BLACKLIST"
fi
if [ -t 0 ] && [[ -z "$force_not_interactive" ]]; then
  # shell is really interactive and "$force_not_interactive" is not set
  run_interactively="true"
else
  run_interactively="false"
fi
log_debug "run_interactively: $run_interactively"

# it serves here as an identificator, will be used as docker container name
# and as a part of env_file
run_id=$(get_run_id)
env_file=$(get_env_vars_file_name "${run_id}")
env_dir=$(dirname "${env_file}")
mkdir -p "${env_dir}"
save_environment_variables "$env_file" "$IDE_VARS_BLACKLIST"

# construct docker command
docker_command=$(construct_docker_command "$env_file" "$run_interactively" "$run_id" "$command")
echo -e "docker command will be:\n${GREEN}${docker_command}${NC}"

on_control_c()
{
    log_error "Ctrl+c caught by IDE."
    if [[ $(docker inspect -f "{{.State.Running}}" "$run_id" ) == "false" ]]; then
      # If Ctrl+c was typed fast enough, docker container is not running, but
      # it is created. If that is the case, remove it.
      log_error "I will remove docker container: $run_id (it was created but not started)"
      docker rm "$run_id"
    else
      log_error "I will stop docker container: $run_id"
      # this can still take some time (up to 10 seconds)
      docker stop "$run_id"
    fi
}
trap 'on_control_c' INT

# run docker run
if [[ "$dryrun" != "true" ]]; then
  if [[ "$run_interactively" == "true" ]]; then
    eval "${docker_command}"
  else
    # run in the background so that user has a moment to run ctrl+c
    # until container did not stop
    eval "${docker_command}" &
    wait
  fi
  exit_status="$?"
  log_debug "ide exit status: $exit_status"
  if [[ "$exit_status" != "0" ]]; then
    log_error "fail! exit status: $exit_status"
    exit $exit_status
  fi
fi

rm -rf "${env_file}"
