#!/bin/bash

log_debug() {
    if [ "$IDE_LOG_LEVEL" == "debug" ]; then
      echo -e "$(date "+%d-%m-%Y %T") $1"
    fi
}

get_env_vars_file_name() {
  echo /tmp/ide/environment-`date +%Y-%m-%d_%H-%M-%S`
}

# Creates a file of format ENV_VAR_NAME="env var value" made up of current
# environment variables. Respects the collection of blacklisted variables ($2).
# If any env variable is blacklisted, it will be saved with "IDE_" prefix.
# If env var wuth "IDE_" prefix already exists, its value is taken, instead of
# the primary variable. E.g. PWD is blacklisted, so it will be saved as
# "IDE_PWD=/some/path", and that "/some/path" is not a value of PWD, but a value
# of IDE_PWD.
# Variables can be also blacklisted with asterix, e.g. BASH*
# $1 is a file path to which we save to, string
# $2 is the collection of blacklisted variables, string separated by commas
save_environment_variables() {

  env_file="$1"
  if [ -z "$env_file" ]; then
    echo "env_file not specified"
    return 1;
  fi
  log_debug "Writing environment variables to $env_file"
  if [ -f "$env_file" ]; then
    rm "$env_file"
  fi

  blacklisted_variables_from_user="$2"
  if [ -z "$blacklisted_variables_from_user" ]; then
    echo "blacklisted_variables_from_user not specified"
    return 1;
  fi

  # Get all the environment variables set.
  # The env command with no arguments will print a list of the "exported"
  # environment variables and their values. These variables are made visible to
  # subprocesses. But the env command prints some variables in 2 lines, e.g.:
  # COMP_WORDBREAKS=
  # "'><;|&(:
  # Thus, and also because I need variables' names separately, I prefer
  # compgen -e.
  host_env=$(compgen -e)

  DOCKER_ENVS_ARRAY=()
  # split blacklisted_variables_from_user with ',' as delimeter
  blacklisted_variables=$(echo $blacklisted_variables_from_user | tr "," "\n")
  for env_var in $host_env ; do
      env_var_value=$(printenv ${env_var})

      blacklisted="false"
      for blacklisted_var in $blacklisted_variables ; do
          if [[ "$blacklisted_var" == *"*" ]]; then
              # this blacklisted variable ends with asterix, e.g. BASH*
              # get its name without asterix, e.g. BASH
              # echo "$blacklisted_var ends with *"
              no_asterix_name=$(echo $blacklisted_var | awk '{ gsub(/\*/, ""); print }')

              if [[ "$env_var" == "$no_asterix_name"* ]]; then
                echo "${env_var}=${env_var_value} blacklisted asterix"
                  DOCKER_ENVS_ARRAY+=("IDE_${env_var}=${env_var_value}")
                  blacklisted="true"
                  break;
              fi
          elif [[ "$env_var" == "$blacklisted_var" ]]; then
            echo "${env_var}=${env_var_value} blacklisted normal"
            echo "IDE_${env_var}=${env_var_value}"
              DOCKER_ENVS_ARRAY+=("IDE_${env_var}=${env_var_value}")
              blacklisted="true"
              break;
          fi
      done
      if [[ "$blacklisted" == "false" ]]; then
        #echo "${env_var}=${env_var_value} NOT blacklisted"
          # this variable was not blacklisted, no need to add prefix before its name
          DOCKER_ENVS_ARRAY+=("${env_var}=${env_var_value}")
      fi
  done
  for env_var in "${DOCKER_ENVS_ARRAY[@]}" ; do
    # echo "$env_var IN ARRAY"
      echo "$env_var" >> "$env_file"
  done
  for env_var in $host_env ; do
      echo "$env_var" >> "all"
  done
}
