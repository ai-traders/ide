#!/bin/bash

log_debug() {
    if [ "$IDE_LOG_LEVEL" == "debug" ]; then
      echo -e "$(date "+%d-%m-%Y %T") $1"
    fi
}

log_error() {
  echo -e "\e[31merror: $1\e[0m"
}

# Returns an identificator that can be reused later in many places,
# e.g. as some file name or as docker container name.
# e.g. ide-dummyide-usage-2016-03-08_18-51-09-68509321
get_run_id() {
  directory_name=$(basename "${PWD}")
  directory_name_no_space="${directory_name/ /_}"
  # It must contain a random number, the time is insufficient.
  # It already was a problem when 2 ci jobs were started in the
  # same second, they wrote to the same file and 2 processes were reading the
  # same file (it concerns function: get_env_vars_file_name).

  # I want to have a long random number, I know this method skews random numbers
  # to the lower regions of boundaries and that it might not work in e.g.
  # busybox docker image. But, is there bash in busybox? If we wanted to port IDE
  # to work on busybox, this would probably demand more work than only
  # other way of getting random numbers. See if this can help then:
  # http://stackoverflow.com/questions/7642743/how-to-generate-random-numbers-in-the-busybox-shell
  random1=$((RANDOM % 10000))
  random2=$((RANDOM % 10000))
  echo "ide-${directory_name_no_space}-$(date +%Y-%m-%d_%H-%M-%S)-${random1}${random2}"
}

# Returns a name of a file which will contain environment variables.
# e.g. /tmp/ide/environment-ide-dummyide-usage-2016-03-08_18-51-09-68509321
get_env_vars_file_name() {

  run_id="$1"
  if [ -z "$run_id" ]; then
    log_error "run_id not specified"
    return 1;
  fi
  echo "/tmp/ide/environment-${run_id}"
}

# $1 is the environment variable name and does not start with IDE_
# Example: $1 is ABC. If IDE_ABC is already set, this method returns
# IDE_ABC=${IDE_ABC}. If IDE_ABC is not set, this method returns IDE_ABC=${ABC}.
help_save_blacklisted_variable() {
  env_var="$1"
  if [ -z "$env_var" ]; then
    log_error "env_var not specified"
    return 1;
  fi
  if [[ "$env_var" == "IDE_"* ]]; then
    log_error "env_var starts with IDE_"
    return 1;
  fi

  ide_env_var="IDE_${env_var}"
  ide_env_var_value=$(printenv "${ide_env_var}")

  if [ -z "$ide_env_var_value" ]; then
      # "IDE_${env_var}" not set
      env_var_value=$(printenv "${env_var}")
      echo "${ide_env_var}=${env_var_value}"
  else
      echo "${ide_env_var}=${ide_env_var_value}"
  fi
}


# Creates a file ($1) of format ENV_VAR_NAME="env var value" made up of current
# environment variables. Respects the collection of blacklisted variables ($2).
# If any env variable is blacklisted, it will be saved with "IDE_" prefix.
# If env var with "IDE_" prefix already exists, its value is taken, instead of
# the primary variable. E.g. PWD is blacklisted, so it will be saved as
# "IDE_PWD=/some/path", and that "/some/path" is a value of IDE_PWD if already
# exists, otherwise of PWD.
# Variables can be also blacklisted with asterix, e.g. BASH*. This means that
# any variable starting with BASH will be prefixed.
# Variables with IDE_ prefix cannot be blacklisted.
#
# $1 is a file path to which we save to, string
# $2 is the collection of blacklisted variables, string separated by commas
function save_environment_variables() {

  env_file="$1"
  if [ -z "$env_file" ]; then
    log_error "env_file not specified"
    return 1;
  fi
  log_debug "Writing environment variables to $env_file"
  if [ -f "$env_file" ]; then
    rm "$env_file"
  fi

  blacklisted_variables_from_user="$2"
  if [ -z "$blacklisted_variables_from_user" ]; then
    log_error "blacklisted_variables_from_user not specified"
    return 1;
  fi
  # split blacklisted_variables_from_user with ',' as delimeter
  blacklisted_variables=$(echo "$blacklisted_variables_from_user" | tr "," "\n")

  for blacklisted_env_var in ${blacklisted_variables} ; do
      # do not allow to blacklist any environment variable which is
      # used by ide with "IDE_" prefix
      if [[ "$blacklisted_env_var" == "WORK" ]]; then
        log_error "blacklisted WORK environment variable"
        return 1;
      fi
      if [[ "$blacklisted_env_var" == "IDENTITY" ]]; then
        log_error "blacklisted IDENTITY environment variable"
        return 1;
      fi
      if [[ "$blacklisted_env_var" == "DRIVER" ]]; then
        log_error "blacklisted DRIVER environment variable"
        return 1;
      fi
      if [[ "$blacklisted_env_var" == "DOCKER_IMAGE" ]]; then
        log_error "blacklisted DOCKER_IMAGE environment variable"
        return 1;
      fi
      if [[ "$blacklisted_env_var" == "DOCKER_OPTIONS" ]]; then
        log_error "blacklisted DOCKER_OPTIONS environment variable"
        return 1;
      fi
  done

  # Get all the environment variables set.
  # The env command with no arguments will print a list of the "exported"
  # environment variables and their values. These variables are made visible to
  # subprocesses. But the env command prints some variables in 2 lines, e.g.:
  # COMP_WORDBREAKS=
  # "'><;|&(:
  # Thus, and also because I need variables' names separately, I prefer
  # compgen -e.
  host_env=$(compgen -e)

  DOCKER_ENVS_ARRAY=()
  for env_var in $host_env ; do
      # now we are looking only for IDE_ variables, for which the no IDE_ variables
      # are not set, e.g. IDE_ABC is set and ABC is not set. Without this,
      # IDE_ABC would be skipped.
      # * what if someone has variable WORK and it is not blacklisted?
      # Then IDE_WORK will never be preserved. And that is fine.
      # * what if someone has variable WORK and is it blacklisted?
      # Its value will override IDE_WORK value. And that will make IDE fail
      # but only in "ide in ide". -- do not allow to blacklist WORK and similar
      # done above
      if [[ "$env_var" == "IDE_"* ]]; then
        env_var_without_prefix=$(echo "$env_var" | awk '{ gsub(/IDE_/, ""); print }')
        skip="false"
        for element in $host_env ; do
            if [[ "$element" == "$env_var_without_prefix" ]]; then
              skip="true"
              log_debug "skipping $element == ${env_var_without_prefix}"
              break;
            fi
        done
        if [[ "$skip" == "true" ]]; then
          log_debug "skipping ${env_var}"
          # skip that variable in order not to save it twice
          continue;
        else
          env_var_value=$(printenv "${env_var}")
          DOCKER_ENVS_ARRAY+=("${env_var}=${env_var_value}")
          log_debug "added ${env_var}=${env_var_value}"
        fi
      fi

      # now consider only variables without IDE_ prefix
      blacklisted="false"
      for blacklisted_var in $blacklisted_variables ; do
          if [[ "$blacklisted_var" == *"*" ]]; then
              # this blacklisted variable ends with asterix, e.g. BASH*
              # get its name without asterix, e.g. BASH
              # echo "$blacklisted_var ends with *"
              no_asterix_name=$(echo "$blacklisted_var" | awk '{ gsub(/\*/, ""); print }')

              if [[ "$env_var" == "$no_asterix_name"* ]]; then
                  log_debug "${env_var} blacklisted because of $blacklisted_var"
                  var_name_value=$(help_save_blacklisted_variable "${env_var}")
                  DOCKER_ENVS_ARRAY+=("${var_name_value}")
                  blacklisted="true"
                  break;
              fi
          elif [[ "$env_var" == "$blacklisted_var" ]]; then
              log_debug "${env_var} blacklisted"
              var_name_value=$(help_save_blacklisted_variable "${env_var}")
              DOCKER_ENVS_ARRAY+=("${var_name_value}")
              blacklisted="true"
              break;
          fi
      done
      if [[ "$blacklisted" == "false" ]]; then
          # too much noise, so commented out:
          # log_debug "${env_var} not blacklisted"
          # this variable was not blacklisted, no need to add prefix before its name
          env_var_value=$(printenv "${env_var}")
          DOCKER_ENVS_ARRAY+=("${env_var}=${env_var_value}")
      fi
  done
  if [ -n "$DISPLAY" ]; then
    # DISPLAY is set, enable running in graphical mode.
    # No matter what was its value, always set it to: unix:0.0
    DOCKER_ENVS_ARRAY+=("DISPLAY=unix:0.0")
  fi
  for env_var in "${DOCKER_ENVS_ARRAY[@]}" ; do
      echo "$env_var" >> "$env_file"
  done
}

# Echoes the docker run command.
# $1 is the file with environment variables to be mounted into docker container
# $2 is the true/false whether to run interactively
# $3 is docker container name
# $4 is docker image name
# $5 is IDE_WORK
# $6 is IDE_IDENTITY
# $7 is remove_containers, whether or not to remove docker container
# $8 is command to be run in docker container
# $9 are docker options
function construct_docker_command() {
  env_file="$1"
  run_interactively="$2"
  container_name="$3"
  image_name="$4"
  ide_work="$5"
  ide_identity="$6"
  remove_containers="$7"
  # can be unset
  command="$8"
  # can be unset
  ide_docker_options="$9"
  if [ -z "$env_file" ]; then
    log_error "env_file not specified"
    return 1;
  fi
  if [ -z "$run_interactively" ]; then
    log_error "run_interactively not specified"
    return 1;
  fi
  if [ -z "$container_name" ]; then
    log_error "container_name not specified"
    return 1;
  fi
  if [ -z "$image_name" ]; then
    log_error "image_name not specified"
    return 1;
  fi
  if [ -z "$ide_work" ]; then
    log_error "ide_work not specified"
    return 1;
  fi
  if [ -z "$ide_identity" ]; then
    log_error "ide_identity not specified"
    return 1;
  fi
  if [ -z "$remove_containers" ]; then
    log_error "remove_containers not specified"
    return 1;
  fi

  # initial part of the docker command
  docker_cmd="docker run"
  if [[ "$remove_containers" == "true" ]]; then
    docker_cmd+=" --rm"
  fi
  docker_cmd+=" -v $ide_work:/ide/work -v $ide_identity:/ide/identity:ro"
  docker_cmd+=" --env-file=\"$env_file\""

  if [ -n "$DISPLAY" ]; then
    # DISPLAY is set, enable running in graphical mode
    docker_cmd+=" -v /tmp/.X11-unix:/tmp/.X11-unix"
  fi

  if [ -n "$ide_docker_options" ]; then
      docker_cmd+=" $ide_docker_options"
  fi

  if [[ "$run_interactively" == "true" ]]; then
      docker_cmd+=" -ti"
  fi

  docker_cmd+=" --name ${container_name}"

  if [ -n "$command" ]; then
    # $command set
    if [[ "$command" == "\""*"\"" ]]; then
      # $command is wrapped with double quotes already
      docker_cmd+=" $image_name $command"
    else
      docker_cmd+=" $image_name \"$command\""
    fi
  else
      # $command not set
      # why? Because, if $command is set, then we want to quote it.
      # And when $command is not set, we don't want quotes.
      docker_cmd+=" $image_name"
  fi

  echo "$docker_cmd"
}

# Echoes the first part of docker-compose command.
# $1 is the file with environment variables to be mounted into docker container
# $2 is the docker-compose yaml file path
# $3 is docker-compose project name
# $4 is IDE_WORK
# $5 is IDE_IDENTITY
function construct_docker_compose_command_part1() {
  env_file="$1"
  docker_compose_file="$2"
  project_name="$3"
  ide_work="$4"
  ide_identity="$5"
  if [ -z "$env_file" ]; then
    log_error "env_file not specified"
    return 1;
  fi
  if [ -z "$docker_compose_file" ]; then
    log_error "docker_compose_file not specified"
    return 1;
  fi
  if [ -z "$project_name" ]; then
    log_error "project_name not specified"
    return 1;
  fi
  if [ -z "$ide_work" ]; then
    log_error "ide_work not specified"
    return 1;
  fi
  if [ -z "$ide_identity" ]; then
    log_error "ide_identity not specified"
    return 1;
  fi

  docker_compose_cmd="IDE_WORK=\"${ide_work}\" IDE_IDENTITY=\"${ide_identity}\" ENV_FILE=\"${env_file}\" docker-compose -f ${docker_compose_file} -p ${project_name}"
  echo "$docker_compose_cmd"
}

# Echoes the docker-compose run command.
# $1 is the file with environment variables to be mounted into docker container
# $2 is the docker-compose yaml file path
# $3 is docker-compose project name
# $4 is the true/false whether to run interactively
# $5 is IDE_WORK
# $6 is IDE_IDENTITY
# $7 is command to be run in docker container
# $8 are docker compose options
function construct_docker_compose_run_command() {
  env_file="$1"
  docker_compose_file="$2"
  project_name="$3"
  run_interactively="$4"
  ide_work="$5"
  ide_identity="$6"
  # can be unset
  command="$7"
  # can be unset
  ide_docker_compose_options="$8"

  # initial part of the docker compose command
  docker_compose_cmd=$(construct_docker_compose_command_part1 "${env_file}" "${docker_compose_file}" "${project_name}" "${ide_work}" "${ide_identity}")
  if [[ "$?" != "0" ]]; then
    log_error "$docker_compose_cmd"
    return 1
  fi

  # first let construct_docker_compose_command_part1 fail, then fail here
  if [ -z "$run_interactively" ]; then
    log_error "run_interactively not specified"
    return 1;
  fi

  docker_compose_cmd+=" run --rm"

  if [[ "$run_interactively" == "false" ]]; then
      docker_compose_cmd+=" -T"
  fi

  if [ -n "$ide_docker_compose_options" ]; then
      docker_compose_cmd+=" $ide_docker_compose_options"
  fi

  docker_compose_cmd+=" default"

  if [ -n "$command" ]; then
    # $command set
    if [[ "$command" == "\""*"\"" ]]; then
      # $command is wrapped with double quotes already
      docker_compose_cmd+=" $command"
    else
      docker_compose_cmd+=" \"$command\""
    fi
  fi

  echo "$docker_compose_cmd"
}

# Echoes the docker-compose stop command.
# $1 is the file with environment variables to be mounted into docker container
# $2 is docker-compose project name
# $3 is the docker-compose yaml file path
# $4 is IDE_WORK
# $5 is IDE_IDENTITY
function construct_docker_compose_stop_command() {
  env_file="$1"
  docker_compose_file="$2"
  project_name="$3"
  ide_work="$4"
  ide_identity="$5"

  docker_compose_cmd=$(construct_docker_compose_command_part1 "${env_file}" "${docker_compose_file}" "${project_name}" "${ide_work}" "${ide_identity}")
  if [[ "$?" != "0" ]]; then
    log_error "$docker_compose_cmd"
    return 1
  fi
  docker_compose_cmd+=" stop"
  echo "$docker_compose_cmd"
}

# Echoes the docker-compose rm command.
# $1 is the file with environment variables to be mounted into docker container
# $2 is docker-compose project name
# $3 is the docker-compose yaml file path
# $4 is IDE_WORK
# $5 is IDE_IDENTITY
function construct_docker_compose_rm_command() {
  env_file="$1"
  docker_compose_file="$2"
  project_name="$3"
  ide_work="$4"
  ide_identity="$5"

  docker_compose_cmd=$(construct_docker_compose_command_part1 "${env_file}" "${docker_compose_file}" "${project_name}" "${ide_work}" "${ide_identity}")
  if [[ "$?" != "0" ]]; then
    log_error "$docker_compose_cmd"
    return 1
  fi
  docker_compose_cmd+=" rm -f"
  echo "$docker_compose_cmd"
}

function verify_docker_compose_file(){
  docker_compose_file="$1"
  if [ -z "$docker_compose_file" ]; then
    log_error "docker_compose_file not specified"
    return 1;
  fi

  contents=$(cat "$docker_compose_file")
  if [[ $(echo "$contents" | grep "IDE_IDENTITY" -c) == "0" ]]; then
    log_error "$docker_compose_file does not contain IDE_IDENTITY"
    exit 1
  fi
  if [[ $(echo "$contents" | grep "IDE_WORK" -c) == "0" ]]; then
    log_error "$docker_compose_file does not contain IDE_WORK"
    exit 1
  fi
  if [[ $(echo "$contents" | grep "ENV_FILE" -c) == "0" ]]; then
    log_error "$docker_compose_file does not contain ENV_FILE"
    exit 1
  fi
  if [[ $(echo "$contents" | grep "IDE_IDENTITY" | grep ":ro" -c) == "0" ]]; then
    log_error "$docker_compose_file does not contain \":ro\" when mounting IDE_IDENTITY"
    exit 1
  fi
  if [[ $(echo "$contents" | grep "^default:" -c) == "0" ]]; then
    log_error "$docker_compose_file does not contain \"default\" container"
    exit 1
  fi
}
